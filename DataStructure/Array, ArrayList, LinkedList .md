# Array, ArrayList, LinkedList

---

# Array

> 데이터가 선형적으로 저장되는 구조
> 
- **메모리 저장 형식**
    
    stack 영역에 저장되며 인접한 메모리에 데이터가 존재한다. ( 컴파일 시 생성 )
    
- **배열의 길이**
    
    배열의 길이가 초기에 정해지며 변경할 수 없다.
    
- **데이터 참조**
    
    Random Access(바로 접근)로 데이터 참조가 쉽다.**O(1)**
    
- **데이터 (중간) 삽입, 삭제**
    
    삽입 삭제 과정에서 데이터의 이동이 빈번하다. **O(N)**
    
- **데이터 추가**
    
    O(1)
    
- **저장되는 데이터**
    - Null : 가능
    - Object : 가능
    - Primitive : 가능
    - 다차원 : 가능
- **순회**
    
    for을 통해 순회 가능하다.
    

# List

> 데이터가 선형적으로 저장되는 구조로 원소의 중복을 허용합니다.
> 

## 구현방법에 의한 종류

### 1. ArrayList

> 배열 기반으로 구현된 List
> 
- **메모리 저장 형식**
    
    stack 영역에 저장되며 인접한 메모리에 데이터가 존재한다.
    
- **배열의 길이**
    
    배열의 길이가 초기에 정해진다. 만약 할당된 크기보다 더 할당을 하려고 하면 배열을 새롭게 만들어야 한다. (resize?)
    
    이를 위해 capacity(size를 나타냄)을 가지고 있다. 이를 넘을 경우 약 1.5배의 capacity로 증가한다.
    
- **데이터 참조**
    
    Random Access(바로 접근)로 데이터 참조가 쉽다.**O(1)**
    
- **데이터 (중간)삽입, 삭제**
    
    삽입 삭제 과정에서 데이터의 이동이 빈번하다.
    
- **데이터 추가**
    
    O(1)
    
    여유공간이 없을 경우 O(N)
    
- **저장되는 데이터**
    - Null : 가능
    - Object : 가능
    - Primitive : 가능
    - 다차원 : 불가능
- **순회**
    
    iterator을 통해 순회 한다.
    

### 2. LinkedList

> 노드 내부에 다음 노드의 위치를 저장하는 방식으로 구현된 List
> 
- **메모리 저장 형식**
    
    heap영역에 저장되며 동적으으로 저장된다. ( 런타임 시 생성 )
    
- **배열의 길이**
    
    정해져있지 않다.
    
- **데이터 참조**
    
    순차적으로 검색하여 찾아야 한다. **O(N)**
    
- **데이터 (중간)삽입, 삭제**
    
    해당하는 위치의 노드의 주소 값을 다음 노드가 가르키고 있는 위치로 변경하면 되기 때문에 간편하다. **O(1) + search** Time
    
- **종류**
    - Single Linked List
        
        단방향으로 연결된 리스트이다. 즉 노드에는 자신의 다음 노드의 주소를 담는 부분 밖에 없다.
        
    - Double Linked List
        
        양방향으로 연결된 리스트이다. 노드에는 자신의 앞 뒤 노드의 주소를 담는 부분이 있다. ⇒ 순회 연산이 가능하고 중간에 넣을 경우 효과가 좋다.
        

---

### 📚참고자료

[[자료구조] List](https://velog.io/@humblechoi/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-List)